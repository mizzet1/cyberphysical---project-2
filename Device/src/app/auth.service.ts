import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';
import { environment } from '../environments/environment';
import { SecureVaultService } from './securevalut.service';
import * as CryptoTS from 'crypto-ts';

@Injectable({
  providedIn: 'root', // This makes the service available application-wide
})
export class AuthService {
  private headers: HttpHeaders = new HttpHeaders({
    'Content-Type': 'application/json',
  });

  constructor(private http: HttpClient, private secureVaultService: SecureVaultService) {}


//generateM1
generateM1(): any{
  const deviceId = environment.device_id;
  const sessionId = this.generateSessionId();
  // Body data to be sent in the POST request
  const M1 = {
    deviceId: deviceId, 
    sessionId: sessionId
  };
  return JSON.stringify(M1);
}

sendM1(): Observable<any>{
  const body = this.generateM1();
  console.log("CLIENT: Sending message M1: ", body);
  return this.http.post('http://localhost:3000/auth/m1', body, {headers: this.headers});
}

//generateSessionId
generateSessionId(){
  const sessionId = Math.floor(Math.random() * 1000).toString();
  localStorage.setItem('sessionId', sessionId);
  return sessionId;
}
 
//generateKey k
generateK1(indices: number[]): string {
  const vault = this.secureVaultService.getVault();
  // XOR all keys at the given indices
  return indices
    .map((index) => vault[index.toString()]) // Fetch keys as hex strings
    .reduce((acc, key) => (parseInt(acc, 16) ^ parseInt(key, 16)).toString(16), '0');
}

// generateT1
generateT1(): string{
  // Generate a random 64-bit (16-character) hexadecimal string
  const t1 = Array.from({ length: 16 }, () =>
    Math.floor(Math.random() * 16).toString(16)
  ).join('');
  localStorage.setItem('t1', t1);
  return t1;
}

//generateC2
generateC2(): number[] {
  const c2: number[] = [];
  // Generates p, a random number from 2 and 7 (i.e. at least 2 keys, at most 7 (n-1) keys). 
  // p determines the number of keys indeces for C2
  const p: number = Math.floor(Math.random() * 6) + 2; 

  const indeces = [0,1,2,3,4,5,6,7];
  for (let i = 0; i < p; i++) {
    const current_index = Math.floor(Math.random() * indeces.length)  
    c2.push(indeces[current_index]);
    indeces.splice(current_index,1); 
  }
  localStorage.setItem('C2', JSON.stringify(c2));
  return c2;
}

//generateR2
generateR2(): string { 
  // Generate a random 64-bit (16-character) hexadecimal string
  const hex = Array.from({ length: 16 }, () =>
    Math.floor(Math.random() * 16).toString(16)
  ).join('');
  return hex;
}
//generateM3
generateM3(r1: string, c1: number[]): string {
  const t1 = this.generateT1();
  const c2 = this.generateC2();
  const r2 = this.generateR2();
  const k1 = this.generateK1(c1); //key k1 generated by C1 indeces
  const m3_json = 
  {
    r1: r1,
    t1: t1,
    C2: c2,
    r2: r2
  };
  //const m3_string = m3_json.toString();
  console.log("CLIENT: \nGenerating M3 ... \nM3: ", JSON.stringify(m3_json).toString());
  const M3_encrypted = CryptoTS.AES.encrypt(JSON.stringify(m3_json), k1);
  return JSON.stringify(M3_encrypted);

}

//sendM3
sendM3(r1: string, c1: number[]): Observable<any> {
  const body = this.generateM3(r1, c1);
  console.log("CLIENT: \nSending message M3 Encrypted: ", body);
  return this.http.post('http://localhost:3000/auth/m3', body, {headers: this.headers});
}

decryptM4(m4: string): any {
  const C2 = JSON.parse(localStorage.getItem('C2')!);
  const k2 = this.generateK1(C2);
  const t1 = localStorage.getItem('t1')!; 
  //XOR t1 and k2
  const k2_t1 = [k2, t1].reduce((acc, key) => (BigInt(`0x${acc}`) ^ BigInt(`0x${key}`)).toString(16), '0');

  console.log("k2_t1: ", k2_t1);

  var bytes = CryptoTS.AES.decrypt(m4, k2_t1).toString(CryptoTS.enc.Utf8);
  console.log("CLIENT: \n bytes M4: " + bytes);

  // var m4_string = CryptoTS.enc.Utf8.stringify(bytes);
  // console.log("CLIENT: \ M4 String: ", m4_string);

  var m4_json = JSON.parse(bytes);
  console.log("CLIENT: \nDecrypted M4: ", bytes);

  return m4_json;
}

generateT(t1: string, t2: string): void{
  const bigIntt1: bigint = BigInt(`0x${t1}`);
  const bigIntt2: bigint = BigInt(`0x${t2}`);
  const T = ( bigIntt1 ^ bigIntt2).toString(16);
  console.log("CLIENT: \nT - Session Key Generated: ", T);
  //Here we assume that T is stored in a secure database
}
}



